/*// could eventually test how many staff lines are at a given measure and adjust the size of the barline from therefunction Pt(){    this.x;    this.y;}function onSegment(p, q, r){    if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&        q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y))       return true;    return false;}// To find orientation of ordered triplet (p, q, r).// The function returns following values// 0 --> p, q and r are colinear// 1 --> Clockwise// 2 --> Counterclockwisefunction orientation( p,  q,  r){    // See 10th slides from following link for derivation of the formula    // http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf    int val = (q.y - p.y) * (r.x - q.x) -              (q.x - p.x) * (r.y - q.y);    if (val == 0) return 0;  // colinear    return (val > 0)? 1: 2; // clock or counterclock wise}// The main function that returns true if line segment 'p1q1'// and 'p2q2' intersect.function doIntersect( p1,  q1,  p2,  q2){    // Find the four orientations needed for general and    // special cases    int o1 = orientation(p1, q1, p2);    int o2 = orientation(p1, q1, q2);    int o3 = orientation(p2, q2, p1);    int o4 = orientation(p2, q2, q1);    // General case    if (o1 != o2 && o3 != o4)        return true;    // Special Cases    // p1, q1 and p2 are colinear and p2 lies on segment p1q1    if (o1 == 0 && onSegment(p1, p2, q1)) return true;    // p1, q1 and p2 are colinear and q2 lies on segment p1q1    if (o2 == 0 && onSegment(p1, q2, q1)) return true;    // p2, q2 and p1 are colinear and p1 lies on segment p2q2    if (o3 == 0 && onSegment(p2, p1, q2)) return true;     // p2, q2 and q1 are colinear and q1 lies on segment p2q2    if (o4 == 0 && onSegment(p2, q1, q2)) return true;    return false; // Doesn't fall in any of the above cases}*/function getGroup(sel, name){    var g = null;    try {        g = sel.groupItems.getByName(name);    }    catch(err) {        var sub = null        try {            sub = sel.groupItems;            for( var i = 0; i < sub.length; i++ )            {                var q = getGroup(sub[i], name);                if(q)                    return q;            }        }        catch(err) {            return null;        }    }    return g;}function  main(){    if ( app.documents.length > 0 )    {        //$.writeln('----------------------');//make UI for these parameters: >>        var mm = 2.834645; //points per mm        var a4 = {h: 210 * mm, w: 297 * mm }; //a4 landscape        var stavesPerPage = 3;        var topMargin = 15 * mm;        var bottomMargin = 15 * mm;        var leftMargin = 20 * mm;        var meterHeight = 10 * mm;        var vSpacing = 5 * mm;        var scaleXY = 1;        var set_scale = true; //<< set to false to scale each system to fit, and print scale factor        var staveHeight = ((a4.h - topMargin - bottomMargin) / stavesPerPage) ;        var instHeight = staveHeight - meterHeight - vSpacing;                //var inst = ['picc', 'ob', 'cl', 'sax', 'perc', 'piano', 'vln', 'vla', 'vc'];        var inst = ['piano'];        //var fullname = ['piccolo', 'oboe', 'clarinet', 'soprano sax', 'percussion', 'piano', 'violin', 'viola', 'violoncello'];        var fullname = 'piano';//<<        var doc = app.activeDocument;        var pages = doc.artboards;        var npages = pages.length;        var layer = doc.layers[0];        for(var k = 0; k < inst.length; k++)        {                        //instrument specific settings:                        if(inst[k] == 'piano')            {                scaleXY = 0.90784293577982;                set_scale = true;                leftMargin = 30 * mm;                topMargin = 10 * mm;                }                                    var num_part_pages = Math.ceil(npages / stavesPerPage);            //make new document            var partDoc = app.documents.add(DocumentColorSpace.CMYK, a4.w, a4.h, num_part_pages,                    DocumentArtboardLayout.GridByRow, 20, 7);            partDoc.name = fullname[k]+'-part';            var partLayer = partDoc.layers[0];                        var player = partDoc.layers.add();                    var pgroup = player.groupItems.add();            pgroup.name = 'rehearsal-marks';                    var pnumlayer = partDoc.layers.add();            var pnumgroup = player.groupItems.add();            pnumgroup.name = 'page-numbers';                        for( var pn = 0; pn < num_part_pages; pn++)            {                            var pnumb = pnumgroup.textFrames.add();                pnumb.contents = fullname[k]+': '+(pn+1);                pnumb.stroked = false;                pnumb.paragraphs[0].characterAttributes.size = 18;                                pnumb.fillColor = 'black';                pnumb.name = 'rehearsal-number';                                   var aboard_r = partDoc.artboards[pn].artboardRect;                                var pnumY = aboard_r[3] + pnumb.height + (8 * mm);                pnumb.position = [ aboard_r[2] - pnumb.width, pnumY ];                pnumb.textRange.justification = Justification.RIGHT;               }                // NOTE: this assumes there is 1 ensemble stave per artboard...        //debug:        //    npages = 1;            for( var i = 0; i < npages; i++ )            {                //get page and stave from original                var page = getGroup(layer, 'page-'+(i+1));                if(!page)                {                    Window.alert("No numbered page groups found");                    return 0;                }                var stave = getGroup(page, inst[k]+'-stave');                if(!stave)                {                    Window.alert("No stave groups found");                    return 0;                }                var ab_idx = Math.floor(i / stavesPerPage);                var ab_rect = partDoc.artboards[ab_idx].artboardRect;                var cc = stave.duplicate(partLayer, ElementPlacement.PLACEATEND);                                        // optionally scale the whole system to fit, but this doesn't look good        // to fix, it might be better to check the whole score and then scale everything to the tallest system        // but maybe even better might be to first try reducing the size of the meters, since in the score this tends        // to be the tallest element -- or adjust the vspan, -- however the vspan isnt' used here, like in the         // draw measures script, since we are copying the whole system directly//                var max_scale = 1;                if(set_scale)                {                    cc.resize(scaleXY* 100., scaleXY* 100.);                }                else if(!set_scale && cc.height > instHeight)                {                    scaleXY = (instHeight / cc.height);                    $.writeln('scaling page '+i+' '+scaleXY);                    cc.resize(scaleXY* 100., scaleXY* 100.);                    //                    max_scale = scaleXY < max_scale ? scaleXY : max_scale; //<< to find the worst case                }            //$.writeln(scaleXY);                //calc where it should be placed in part                var localY = ((i % stavesPerPage) * staveHeight) + (vSpacing * (i > 0));                var delta_x = ab_rect[0] - cc.left + leftMargin;                var delta_y = ab_rect[1] - cc.top - topMargin - localY - meterHeight;                cc.translate(delta_x, delta_y);                cc.name = cc.name+'-'+(i+1);                        // make rehearsal numbers (same as page numbers for now)                var numbox = pgroup.groupItems.add();                numbox.name = 'rehearsal-mark';                            var pnum = numbox.textFrames.add();                pnum.contents = String(i+1);                pnum.stroked = false;                pnum.fillColor = 'black';                pnum.name = 'rehearsal-number';                                   pnum.position = [0, 0];                pnum.textRange.justification = Justification.CENTER;                               var diam = Math.ceil(pnum.height > pnum.width ? pnum.height : pnum.width);                var rad = Math.ceil(diam / 2.);                var box = numbox.pathItems.rectangle(0, 0, diam, diam);                box.stroked = true;                box.filled = false;                box.translate(-rad, -rad+Math.ceil(pnum.height/2));                                var px = cc.left - pnum.width - 10;//((x2 - x1) / 2)                var py = cc.top - (cc.height / 2) + (pnum.height / 2);                                numbox.translate(px, py);            //draw measures and other special markings                var items = page.pageItems;                var j;                for( j = 0; j < items.length; j++ )                {                                        if(items[j].name.split('-')[0] == 'tempo')                    {                        //$.writeln(items[j].name);                        var tgroup = partLayer.groupItems.add();                        tgroup.name = items[j].name;                        var t_localX = (items[j].left - stave.left) * scaleXY;                        var t = items[j].duplicate(partLayer, ElementPlacement.PLACEATEND);                        var tx = ab_rect[0] - t.left + t_localX + leftMargin;                        var ty = ab_rect[1] - t.top - localY - topMargin + meterHeight;                                                t.translate(tx, ty);                        var tscaleXY = 1;                        if(t.height > meterHeight)                        {                            tscaleXY = (meterHeight / t.height);                            t.resize(tscaleXY * 100., tscaleXY * 100.);                        }                        t.moveToBeginning(tgroup);                                            }                    else if(items[j].name.split('-')[0] == 'cautionary')                    {                        var mgroup = partLayer.groupItems.add();                        mgroup.name = items[j].name;                        //copy, place, and resize meter if necessary                        try {                            var meter = items[j].pageItems.getByName('meter');                            var m_localX = (meter.left - stave.left) * scaleXY;                            var m = meter.duplicate(partLayer, ElementPlacement.PLACEATEND);                            var mx = ab_rect[0] - m.left + m_localX + leftMargin;                            var my = ab_rect[1] - m.top - localY - topMargin - meterHeight + m.height;                                                        m.translate(mx, my);                            var mscaleXY = 1;                            if(m.height > meterHeight)                            {                                mscaleXY = (meterHeight / m.height);                                m.resize(mscaleXY * 100., mscaleXY * 100.);                            }                            m.moveToBeginning(mgroup);                        }                        catch(err){}                    }                    else if(items[j].name.split('-')[0] == 'measure')                    {                        var mgroup = partLayer.groupItems.add();                        mgroup.name = items[j].name;                        //copy, place, and resize meter if necessary                        try {                            var meter = items[j].pageItems.getByName('meter');                            var m_localX = (meter.left - stave.left) * scaleXY;                            var m = meter.duplicate(partLayer, ElementPlacement.PLACEATEND);                            var mx = ab_rect[0] - m.left + m_localX + leftMargin;                            var my = ab_rect[1] - m.top - localY - topMargin - meterHeight + m.height;                                                        m.translate(mx, my);                            var mscaleXY = 1;                            if(m.height > meterHeight)                            {                                mscaleXY = (meterHeight / m.height);                                m.resize(mscaleXY * 100., mscaleXY * 100.);                            }                            m.moveToBeginning(mgroup);                        }                        catch(err){}                        //draw barline for individual part                        //check for double bar, and final bar                                                try {                            var barline = items[j].pageItems.getByName('double-barline');                            //throws error if not found                                                        var ll;                            for(ll=0; ll<2; ll++)                            {                                var b_localX = (barline.left - stave.left) * scaleXY;                                var b = mgroup.pathItems.add();                                b.stroked = true;                                b.name = "barline";                                var bx = (cc.left + b_localX) + (ll * mm);                                b.setEntirePath([ [ bx, cc.top ], [ bx, cc.top - cc.height ] ]);                            }                                                    }                        catch(err){                                                        try {                                var barline = items[j].pageItems.getByName('final-barline');                                //throws error if not found                                var b_localX = (barline.left - stave.left) * scaleXY;                                var stroke_w = [0.5, 3];                                                                var ll;                                for(ll=0; ll<2; ll++)                                {                                    var b = mgroup.pathItems.add();                                    b.stroked = true;                                    b.strokeWidth = stroke_w[ll];                                    b.name = "barline";                                    var bx = (cc.left + b_localX) + (ll * mm);                                    b.setEntirePath([ [ bx, cc.top ], [ bx, cc.top - cc.height ] ]);                                }                            }                            catch(err){                                                                try {                                    var barline = items[j].pageItems.getByName('barline');                                    //throws error if not found                                    var b_localX = (barline.left - stave.left) * scaleXY;                                    var b = mgroup.pathItems.add();                                    b.stroked = true;                                    b.name = "barline";            //NOTE: I think we have to use the cc. values directly, since the coordinate system might change suddenly?                                    var bx = (cc.left + b_localX);                                    b.setEntirePath([ [ bx, cc.top ], [ bx, cc.top - cc.height ] ]);                                }                                catch(err){}                                                            }                        }                        //mgroup.moveToBeginning(cc);                    }                }            }        }    }else{        Window.alert("You must open at least one document.");    }}main();/*   var mpos = partDoc.convertCoordinate(items[j].position,        CoordinateSystem.ARTBOARDCOORDINATESYSTEM,        CoordinateSystem.DOCUMENTCOORDINATESYSTEM); */